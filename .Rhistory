# Note: these results will not be used in this tutorial (but we need to specify a selection anyway)
select_direct_indicator<-c("ifo_c","ESI")
perf_obj<-compute_perf_func(x_mat,target_shifted_mat,predictor_mssa_mat,predictor_mmse_mat,in_out_separator,select_direct_indicator,h_vec)
# Regression on HP-BIP, without pandemic
p_value_HAC_HP_BIP_oos_wc<-perf_obj$p_value_HAC_HP_BIP_oos_wc
p_value_HAC_HP_BIP_oos_wc
# Select start of out-of-sample span (entire financial crisis is out-of-sample)
in_out_separator<-"2007"
# We can specify the selection of macro-indicators for the direct forecast, see tutorial 7.3
#   Note: these results will not be used here (but we need to specify a selection anyway)
select_direct_indicator<-c("ifo_c","ESI")
perf_obj<-compute_perf_func(x_mat,target_shifted_mat,predictor_mssa_mat,predictor_mmse_mat,in_out_separator,select_direct_indicator,h_vec)
# Regression on HP-BIP, without pandemic
p_value_HAC_HP_BIP_oos_wc<-perf_obj$p_value_HAC_HP_BIP_oos_wc
p_value_HAC_HP_BIP_oos_wc
# Select start of out-of-sample span (entire financial crisis is out-of-sample)
in_out_separator<-"2007"
# We can specify the selection of macro-indicators for the direct forecast, see tutorial 7.3
#   Note: these results will not be used here (but we need to specify a selection anyway)
select_direct_indicator<-c("ifo_c","ESI")
perf_obj<-compute_perf_func(x_mat,target_shifted_mat,predictor_mssa_mat,predictor_mmse_mat,in_out_separator,select_direct_indicator,h_vec)
# Regression on HP-BIP, without pandemic
p_value_HAC_HP_BIP_oos_wc<-perf_obj$p_value_HAC_HP_BIP_oos_wc
p_value_HAC_HP_BIP_oos_wc
sel_vec_pred<-c("BIP")
shift_vec<-0:5
if (recompute_results)
{
# Initialize performance matrices
MSE_oos_mssa_comp_without_covid_mat<-MSE_oos_mssa_comp_mat<-p_mat_mssa<-p_mat_mssa_components<-p_mat_mssa_components_without_covid<-p_mat_direct<-rRMSE_mSSA_comp_direct<-rRMSE_mSSA_comp_mean<-rRMSE_mSSA_comp_direct_without_covid<-rRMSE_mSSA_comp_mean_without_covid<-rRMSE_mSSA_direct_mean_without_covid<-rRMSE_mSSA_direct_mean<-p_mat_direct_without_covid<-matrix(ncol=length(h_vec),nrow=length(h_vec)-1)
final_components_preditor_array<-oos_components_preditor_array<-array(dim=c(length(shift_vec),length(h_vec),nrow(x_mat)))
dimnames(final_components_preditor_array)<-dimnames(oos_components_preditor_array)<-list(paste("shift=",shift_vec,sep=""),
paste("h=",h_vec,sep=""),rownames(x_mat))
# Initialize arrays collecting final predictors, real-time predictors and regression weights
#   -These will be used when analyzing revisions
track_weights_array<-array(dim=c(length(shift_vec),length(h_vec),nrow(x_mat),length(sel_vec_pred)+1))
dimnames(track_weights_array)<-list(paste("shift=",shift_vec,sep=""),
paste("h=",h_vec,sep=""),rownames(x_mat),c("Intercept",sel_vec_pred))
# Use OLS
use_garch<-F
# Set-up progress bar: indicates progress in R-console
pb <- txtProgressBar(min=min(h_vec),max=max(h_vec)-1,style=3)
# The following double loop computes all combinations of forward-shifts (of BIP) and forecast horizons (of M-SSA)
for (shift in shift_vec)#shift<-1
{
# Progress bar: see R-console
setTxtProgressBar(pb, shift)
for (j in h_vec)#j<-0
{
# Horizon j corresponds to k=j+1-th entry of array
k<-j+1
# A. M-SSA component predictor
# Specify data matrix for WLS regression
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(mssa_array[sel_vec_pred,,k]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(mssa_array[sel_vec_pred,,k]))
}
rownames(dat)<-rownames(x_mat)
colnames(dat)<-c(colnames(x_mat)[1],sel_vec_pred)
# Apply the previous function: compute GARCH, WLS regression, out-of-sample MSEs and p-values
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Retrieve out-of-sample performances
# a. p-values with/without Pandemic
p_mat_mssa_components[shift+1,k]<-perf_obj$p_value
p_mat_mssa_components_without_covid[shift+1,k]<-perf_obj$p_value_without_covid
# b. MSE forecast error out-of-sample
#   -M-SSA components with/without Pandemic
MSE_oos_mssa_comp_mat[shift+1,k]<-MSE_oos_mssa_comp<-perf_obj$MSE_oos
MSE_oos_mssa_comp_without_covid_mat[shift+1,k]<-MSE_oos_mssa_comp_without_covid<-perf_obj$MSE_oos_without_covid
#   -mean-benchmark with/without Pandemic
MSE_mean_oos<-perf_obj$MSE_mean_oos
MSE_mean_oos_without_covid<-perf_obj$MSE_mean_oos_without_covid
# Here we retrieve the final in-sample predictor (based on the full-sample WLS regression) as well as the
#    real-time out-of-sample predictor (re-adjusted to new data at each time point)
# We can plot both predictors to illustrate revisions (due to WLS estimation at each time point), see below
final_in_sample_preditor<-perf_obj$final_in_sample_preditor
final_components_preditor_array[shift+1,j+1,(nrow(x_mat)-length(final_in_sample_preditor)+1):nrow(x_mat)]<-final_in_sample_preditor
cal_oos_pred<-perf_obj$cal_oos_pred
oos_components_preditor_array[shift+1,j+1,(nrow(x_mat)-length(cal_oos_pred)+1):nrow(x_mat)]<-cal_oos_pred
# We can also obtain the regression weights to track changes (systematic vs. noisy revisions) over time
# Note: the variable will be overwritten, i.e., we keep only the last run through the double loop,
#   corresponding to maximal shift and maximal forecast horizon, see exercise 2.2 below
track_weights<-perf_obj$track_weights
track_weights_array[shift+1,j+1,(nrow(x_mat)-nrow(track_weights)+1):nrow(x_mat),]<-track_weights
# B. Direct forecasts
# -The main difference to M-SSA above is the specification of the explanatory variables in the data
#     matrix dat: we here use x_mat instead of mssa_array.
#   -We select all indicators (one could easily change this setting but results are only marginally effected as long as ifo and ESi are included)
#   -Note that the data matrix here does not depend on j, in contrast  to the M-SSA components above
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),x_mat)
rownames(dat)<-rownames(x_mat)
dat<-dat
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Retrieve out-of-sample performances: p-values and forecast MSE, with/without Pandemic
p_mat_direct[shift+1,k]<-perf_obj$p_value
p_mat_direct_without_covid[shift+1,k]<-perf_obj$p_value_without_covid
MSE_oos_direct<-perf_obj$MSE_oos
MSE_oos_direct_without_covid<-perf_obj$MSE_oos_without_covid
# Compute rRMSEs
# a. M-SSA Components vs. direct forecast
rRMSE_mSSA_comp_direct[shift+1,k]<-sqrt(MSE_oos_mssa_comp/MSE_oos_direct)
# b. M-SSA Components vs. mean benchmark
rRMSE_mSSA_comp_mean[shift+1,k]<-sqrt(MSE_oos_mssa_comp/MSE_mean_oos)
# c. Direct forecast vs. mean benchmark
rRMSE_mSSA_direct_mean[shift+1,k]<-sqrt(MSE_oos_direct/MSE_mean_oos)
# Same as a, b, c but without Pandemic
rRMSE_mSSA_comp_direct_without_covid[shift+1,k]<-sqrt(MSE_oos_mssa_comp_without_covid/MSE_oos_direct_without_covid)
rRMSE_mSSA_comp_mean_without_covid[shift+1,k]<-sqrt(MSE_oos_mssa_comp_without_covid/MSE_mean_oos_without_covid)
rRMSE_mSSA_direct_mean_without_covid[shift+1,k]<-sqrt(MSE_oos_direct_without_covid/MSE_mean_oos_without_covid)
}
}
# Close progress bar
close(pb)
# Note: possible warnings issued by the GARCH estimation routine during computations can be ignored
# Assign column and rownames
colnames(p_mat_mssa_components)<-colnames(p_mat_direct)<-colnames(p_mat_mssa_components_without_covid)<-
colnames(rRMSE_mSSA_comp_direct)<-colnames(rRMSE_mSSA_comp_mean)<-
colnames(rRMSE_mSSA_comp_direct_without_covid)<-colnames(rRMSE_mSSA_comp_mean_without_covid)<-
colnames(rRMSE_mSSA_direct_mean)<-colnames(rRMSE_mSSA_direct_mean_without_covid)<-
colnames(p_mat_direct_without_covid)<-colnames(MSE_oos_mssa_comp_mat)<-
colnames(MSE_oos_mssa_comp_without_covid_mat)<-paste("h=",h_vec,sep="")
rownames(p_mat_mssa_components)<-rownames(p_mat_direct)<-rownames(p_mat_mssa_components_without_covid)<-
rownames(rRMSE_mSSA_comp_direct)<-rownames(rRMSE_mSSA_comp_mean)<-
rownames(rRMSE_mSSA_comp_direct_without_covid)<-rownames(rRMSE_mSSA_comp_mean_without_covid)<-
rownames(rRMSE_mSSA_direct_mean)<-rownames(rRMSE_mSSA_direct_mean_without_covid)<-
rownames(p_mat_direct_without_covid)<-rownames(MSE_oos_mssa_comp_mat)<-
rownames(MSE_oos_mssa_comp_without_covid_mat)<-paste("Shift=",shift_vec,sep="")
# Define list for saving all matrices
list_perf<-list(p_mat_mssa_components=p_mat_mssa_components,p_mat_direct=p_mat_direct,
p_mat_mssa_components_without_covid=p_mat_mssa_components_without_covid,rRMSE_mSSA_comp_direct=rRMSE_mSSA_comp_direct,
rRMSE_mSSA_comp_mean=rRMSE_mSSA_comp_mean, rRMSE_mSSA_comp_direct_without_covid=rRMSE_mSSA_comp_direct_without_covid,
rRMSE_mSSA_comp_mean_without_covid=rRMSE_mSSA_comp_mean_without_covid,rRMSE_mSSA_direct_mean=rRMSE_mSSA_direct_mean,
rRMSE_mSSA_direct_mean_without_covid=rRMSE_mSSA_direct_mean_without_covid,p_mat_direct_without_covid=p_mat_direct_without_covid,
final_components_preditor_array=final_components_preditor_array,oos_components_preditor_array=oos_components_preditor_array,track_weights_array=track_weights_array,MSE_oos_mssa_comp_mat=MSE_oos_mssa_comp_mat,
MSE_oos_mssa_comp_without_covid_mat=MSE_oos_mssa_comp_without_covid_mat)
# The results can be saved (overwritten)
if (F)
{
save(list_perf,file=paste(path.result,"list_perf",sep=""))
}
} else
{
# Load all results
load(file=paste(path.result,"list_perf",sep=""))
p_mat_mssa_components=list_perf$p_mat_mssa_components
p_mat_direct=list_perf$p_mat_direct
p_mat_mssa_components_without_covid=list_perf$p_mat_mssa_components_without_covid
rRMSE_mSSA_comp_direct=list_perf$rRMSE_mSSA_comp_direct
rRMSE_mSSA_comp_mean=list_perf$rRMSE_mSSA_comp_mean
rRMSE_mSSA_comp_direct_without_covid=list_perf$rRMSE_mSSA_comp_direct_without_covid
rRMSE_mSSA_comp_mean_without_covid=list_perf$rRMSE_mSSA_comp_mean_without_covid
rRMSE_mSSA_direct_mean=list_perf$rRMSE_mSSA_direct_mean
rRMSE_mSSA_direct_mean_without_covid=list_perf$rRMSE_mSSA_direct_mean_without_covid
p_mat_direct_without_covid=list_perf$p_mat_direct_without_covid
final_components_preditor_array=list_perf$final_components_preditor_array
oos_components_preditor_array=list_perf$oos_components_preditor_array
track_weights_array=list_perf$track_weights_array
MSE_oos_mssa_comp_mat=list_perf$MSE_oos_mssa_comp_mat
MSE_oos_mssa_comp_without_covid_mat=list_perf$MSE_oos_mssa_comp_without_covid_mat
}
p_mat_mssa_components_without_covid
p_mat_mssa_components_without_covid
# The link between the new predictor and future BIP is statistically significant up to multiple quarters ahead
#   -Designs optimized for larger forecast horizons (columns with h>=4) seem to perform significantly up to
#     one year ahead
# Same but for direct forecast
p_mat_direct_without_covid[,1]
rRMSE_mSSA_direct_mean_without_covid[,1]
rRMSE_mSSA_comp_direct_without_covid
in_out_separator<-"2007"
# We can specify the selection of macro-indicators for the direct forecast, see tutorial 7.3
#   Note: these results will not be used here (but we need to specify a selection anyway)
select_direct_indicator<-c("ifo_c","ESI")
perf_obj<-compute_perf_func(x_mat,target_shifted_mat,predictor_mssa_mat,predictor_mmse_mat,in_out_separator,select_direct_indicator,h_vec)
# Regression on HP-BIP, without pandemic
p_value_HAC_HP_BIP_oos_wc<-perf_obj$p_value_HAC_HP_BIP_oos_wc
p_value_HAC_HP_BIP_oos_wc
sel_vec_pred<-c("BIP")
shift_vec<-0:5
if (recompute_results)
{
# Initialize performance matrices
MSE_oos_mssa_comp_without_covid_mat<-MSE_oos_mssa_comp_mat<-p_mat_mssa<-p_mat_mssa_components<-p_mat_mssa_components_without_covid<-p_mat_direct<-rRMSE_mSSA_comp_direct<-rRMSE_mSSA_comp_mean<-rRMSE_mSSA_comp_direct_without_covid<-rRMSE_mSSA_comp_mean_without_covid<-rRMSE_mSSA_direct_mean_without_covid<-rRMSE_mSSA_direct_mean<-p_mat_direct_without_covid<-matrix(ncol=length(h_vec),nrow=length(h_vec)-1)
final_components_preditor_array<-oos_components_preditor_array<-array(dim=c(length(shift_vec),length(h_vec),nrow(x_mat)))
dimnames(final_components_preditor_array)<-dimnames(oos_components_preditor_array)<-list(paste("shift=",shift_vec,sep=""),
paste("h=",h_vec,sep=""),rownames(x_mat))
# Initialize arrays collecting final predictors, real-time predictors and regression weights
#   -These will be used when analyzing revisions
track_weights_array<-array(dim=c(length(shift_vec),length(h_vec),nrow(x_mat),length(sel_vec_pred)+1))
dimnames(track_weights_array)<-list(paste("shift=",shift_vec,sep=""),
paste("h=",h_vec,sep=""),rownames(x_mat),c("Intercept",sel_vec_pred))
# Use OLS
use_garch<-F
# Set-up progress bar: indicates progress in R-console
pb <- txtProgressBar(min=min(h_vec),max=max(h_vec)-1,style=3)
# The following double loop computes all combinations of forward-shifts (of BIP) and forecast horizons (of M-SSA)
for (shift in shift_vec)#shift<-1
{
# Progress bar: see R-console
setTxtProgressBar(pb, shift)
for (j in h_vec)#j<-0
{
# Horizon j corresponds to k=j+1-th entry of array
k<-j+1
# A. M-SSA component predictor
# Specify data matrix for WLS regression
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(mssa_array[sel_vec_pred,,k]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(mssa_array[sel_vec_pred,,k]))
}
rownames(dat)<-rownames(x_mat)
colnames(dat)<-c(colnames(x_mat)[1],sel_vec_pred)
# Apply the previous function: compute GARCH, WLS regression, out-of-sample MSEs and p-values
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Retrieve out-of-sample performances
# a. p-values with/without Pandemic
p_mat_mssa_components[shift+1,k]<-perf_obj$p_value
p_mat_mssa_components_without_covid[shift+1,k]<-perf_obj$p_value_without_covid
# b. MSE forecast error out-of-sample
#   -M-SSA components with/without Pandemic
MSE_oos_mssa_comp_mat[shift+1,k]<-MSE_oos_mssa_comp<-perf_obj$MSE_oos
MSE_oos_mssa_comp_without_covid_mat[shift+1,k]<-MSE_oos_mssa_comp_without_covid<-perf_obj$MSE_oos_without_covid
#   -mean-benchmark with/without Pandemic
MSE_mean_oos<-perf_obj$MSE_mean_oos
MSE_mean_oos_without_covid<-perf_obj$MSE_mean_oos_without_covid
# Here we retrieve the final in-sample predictor (based on the full-sample WLS regression) as well as the
#    real-time out-of-sample predictor (re-adjusted to new data at each time point)
# We can plot both predictors to illustrate revisions (due to WLS estimation at each time point), see below
final_in_sample_preditor<-perf_obj$final_in_sample_preditor
final_components_preditor_array[shift+1,j+1,(nrow(x_mat)-length(final_in_sample_preditor)+1):nrow(x_mat)]<-final_in_sample_preditor
cal_oos_pred<-perf_obj$cal_oos_pred
oos_components_preditor_array[shift+1,j+1,(nrow(x_mat)-length(cal_oos_pred)+1):nrow(x_mat)]<-cal_oos_pred
# We can also obtain the regression weights to track changes (systematic vs. noisy revisions) over time
# Note: the variable will be overwritten, i.e., we keep only the last run through the double loop,
#   corresponding to maximal shift and maximal forecast horizon, see exercise 2.2 below
track_weights<-perf_obj$track_weights
track_weights_array[shift+1,j+1,(nrow(x_mat)-nrow(track_weights)+1):nrow(x_mat),]<-track_weights
# B. Direct forecasts
# -The main difference to M-SSA above is the specification of the explanatory variables in the data
#     matrix dat: we here use x_mat instead of mssa_array.
#   -We select all indicators (one could easily change this setting but results are only marginally effected as long as ifo and ESi are included)
#   -Note that the data matrix here does not depend on j, in contrast  to the M-SSA components above
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),x_mat)
rownames(dat)<-rownames(x_mat)
dat<-dat
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Retrieve out-of-sample performances: p-values and forecast MSE, with/without Pandemic
p_mat_direct[shift+1,k]<-perf_obj$p_value
p_mat_direct_without_covid[shift+1,k]<-perf_obj$p_value_without_covid
MSE_oos_direct<-perf_obj$MSE_oos
MSE_oos_direct_without_covid<-perf_obj$MSE_oos_without_covid
# Compute rRMSEs
# a. M-SSA Components vs. direct forecast
rRMSE_mSSA_comp_direct[shift+1,k]<-sqrt(MSE_oos_mssa_comp/MSE_oos_direct)
# b. M-SSA Components vs. mean benchmark
rRMSE_mSSA_comp_mean[shift+1,k]<-sqrt(MSE_oos_mssa_comp/MSE_mean_oos)
# c. Direct forecast vs. mean benchmark
rRMSE_mSSA_direct_mean[shift+1,k]<-sqrt(MSE_oos_direct/MSE_mean_oos)
# Same as a, b, c but without Pandemic
rRMSE_mSSA_comp_direct_without_covid[shift+1,k]<-sqrt(MSE_oos_mssa_comp_without_covid/MSE_oos_direct_without_covid)
rRMSE_mSSA_comp_mean_without_covid[shift+1,k]<-sqrt(MSE_oos_mssa_comp_without_covid/MSE_mean_oos_without_covid)
rRMSE_mSSA_direct_mean_without_covid[shift+1,k]<-sqrt(MSE_oos_direct_without_covid/MSE_mean_oos_without_covid)
}
}
# Close progress bar
close(pb)
# Note: possible warnings issued by the GARCH estimation routine during computations can be ignored
# Assign column and rownames
colnames(p_mat_mssa_components)<-colnames(p_mat_direct)<-colnames(p_mat_mssa_components_without_covid)<-
colnames(rRMSE_mSSA_comp_direct)<-colnames(rRMSE_mSSA_comp_mean)<-
colnames(rRMSE_mSSA_comp_direct_without_covid)<-colnames(rRMSE_mSSA_comp_mean_without_covid)<-
colnames(rRMSE_mSSA_direct_mean)<-colnames(rRMSE_mSSA_direct_mean_without_covid)<-
colnames(p_mat_direct_without_covid)<-colnames(MSE_oos_mssa_comp_mat)<-
colnames(MSE_oos_mssa_comp_without_covid_mat)<-paste("h=",h_vec,sep="")
rownames(p_mat_mssa_components)<-rownames(p_mat_direct)<-rownames(p_mat_mssa_components_without_covid)<-
rownames(rRMSE_mSSA_comp_direct)<-rownames(rRMSE_mSSA_comp_mean)<-
rownames(rRMSE_mSSA_comp_direct_without_covid)<-rownames(rRMSE_mSSA_comp_mean_without_covid)<-
rownames(rRMSE_mSSA_direct_mean)<-rownames(rRMSE_mSSA_direct_mean_without_covid)<-
rownames(p_mat_direct_without_covid)<-rownames(MSE_oos_mssa_comp_mat)<-
rownames(MSE_oos_mssa_comp_without_covid_mat)<-paste("Shift=",shift_vec,sep="")
# Define list for saving all matrices
list_perf<-list(p_mat_mssa_components=p_mat_mssa_components,p_mat_direct=p_mat_direct,
p_mat_mssa_components_without_covid=p_mat_mssa_components_without_covid,rRMSE_mSSA_comp_direct=rRMSE_mSSA_comp_direct,
rRMSE_mSSA_comp_mean=rRMSE_mSSA_comp_mean, rRMSE_mSSA_comp_direct_without_covid=rRMSE_mSSA_comp_direct_without_covid,
rRMSE_mSSA_comp_mean_without_covid=rRMSE_mSSA_comp_mean_without_covid,rRMSE_mSSA_direct_mean=rRMSE_mSSA_direct_mean,
rRMSE_mSSA_direct_mean_without_covid=rRMSE_mSSA_direct_mean_without_covid,p_mat_direct_without_covid=p_mat_direct_without_covid,
final_components_preditor_array=final_components_preditor_array,oos_components_preditor_array=oos_components_preditor_array,track_weights_array=track_weights_array,MSE_oos_mssa_comp_mat=MSE_oos_mssa_comp_mat,
MSE_oos_mssa_comp_without_covid_mat=MSE_oos_mssa_comp_without_covid_mat)
# The results can be saved (overwritten)
if (F)
{
save(list_perf,file=paste(path.result,"list_perf",sep=""))
}
} else
{
# Load all results
load(file=paste(path.result,"list_perf",sep=""))
p_mat_mssa_components=list_perf$p_mat_mssa_components
p_mat_direct=list_perf$p_mat_direct
p_mat_mssa_components_without_covid=list_perf$p_mat_mssa_components_without_covid
rRMSE_mSSA_comp_direct=list_perf$rRMSE_mSSA_comp_direct
rRMSE_mSSA_comp_mean=list_perf$rRMSE_mSSA_comp_mean
rRMSE_mSSA_comp_direct_without_covid=list_perf$rRMSE_mSSA_comp_direct_without_covid
rRMSE_mSSA_comp_mean_without_covid=list_perf$rRMSE_mSSA_comp_mean_without_covid
rRMSE_mSSA_direct_mean=list_perf$rRMSE_mSSA_direct_mean
rRMSE_mSSA_direct_mean_without_covid=list_perf$rRMSE_mSSA_direct_mean_without_covid
p_mat_direct_without_covid=list_perf$p_mat_direct_without_covid
final_components_preditor_array=list_perf$final_components_preditor_array
oos_components_preditor_array=list_perf$oos_components_preditor_array
track_weights_array=list_perf$track_weights_array
MSE_oos_mssa_comp_mat=list_perf$MSE_oos_mssa_comp_mat
MSE_oos_mssa_comp_without_covid_mat=list_perf$MSE_oos_mssa_comp_without_covid_mat
}
# HAC-adjusted p-values of out-of-sample (M-SSA) components predictor when targeting forward-shifted BIP
#   -Evaluation based on out-of-sample span starting at in_out_separator and ending on Jan-2025
#   -Without singular Pandemic
p_mat_mssa_components_without_covid
# The link between the new predictor and future BIP is statistically significant up to multiple quarters ahead
#   -Designs optimized for larger forecast horizons (columns with h>=4) seem to perform significantly up to
#     one year ahead
# Same but for direct forecast
p_mat_direct_without_covid[,1]
h<-4
shift<-4
par(mfrow=c(1,1))
mplot<-cbind(final_components_preditor_array[shift,h,],oos_components_preditor_array[shift,h,])
colnames(mplot)<-c("Final predictor","Real-time out-of-sample predictor")
colo<-c("blue",rainbow(length(select_vec_multi)))
main_title<-paste("Final vs. real-time predictor: h=",h,", shift=",shift,sep=""
)
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],lwd=1,ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i],lwd=1,lty=1)
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
abline(h=0)
#abline(v=which(rownames(mplot)<=date_to_fit)[length(which(rownames(mplot)<=date_to_fit))],lwd=2,lty=2)
axis(1,at=c(1,4*1:(nrow(mplot)/4)),labels=rownames(mplot)[c(1,4*1:(nrow(mplot)/4))])
axis(2)
box()
par(mfrow=c(1,1))
mplot<-track_weights_array[shift,h,,]
#colnames(mplot)[2:ncol(track_weights)]<-paste("Weight of M-SSA component ",colnames(track_weights)[2:ncol(track_weights)])
colo<-c("black","blue","red")
main_title<-paste("Intercept and regression weight over time: h=",h,", shift=",shift,sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],lwd=1,ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i],lwd=1,lty=1)
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
abline(h=0)
#abline(v=which(rownames(mplot)<=date_to_fit)[length(which(rownames(mplot)<=date_to_fit))],lwd=2,lty=2)
axis(1,at=c(1,4*1:(nrow(mplot)/4)),labels=rownames(mplot)[c(1,4*1:(nrow(mplot)/4))])
axis(2)
box()
# Up-date M-SSA and M-MSE
# In-sample span for VAR, use all data for VAR
date_to_fit_all<-"3000"
# Remove Pandemic
x_mat_wc<-x_mat[c(which(rownames(x_mat)<2020),which(rownames(x_mat)>2021)),]
par(mfrow=c(1,1))
ts.plot(x_mat_wc)
# Run the M-SSA wrapper, see tutorial 7.2
#   -The function computes M-SSA and M-MSE for each forecast horizon h in h_vec
if (recompute_results)
{
final_mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat_wc,lambda_HP,L,date_to_fit_all,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
save(final_mssa_indicator_obj,file=paste(path.result,"/final_mssa_indicator_obj",sep=""))
} else
{
load(file=paste(path.result,"/final_mssa_indicator_obj",sep=""))
}
# Final M-SSA components
final_mssa_array<-final_mssa_indicator_obj$mssa_array
#----------------------
# Compute up-dated M-SSA component predictors
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),t(final_mssa_array[sel_vec_pred,,h+1]))
} else
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),(final_mssa_array[sel_vec_pred,,h+1]))
}
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)])
optimal_weights<-lm_obj$coef
# Compute predictor for each forward-shift
if (length(sel_vec_pred)>1)
{
final_mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]%*%optimal_weights[2:length(optimal_weights)]
} else
{
final_mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]*optimal_weights[2:length(optimal_weights)]
}
# Compare and plot old and final M-SSA BIP component predictors
#   Standardize predictors to isolate VAR-revision from total revision (including regression revission)
mssa_final_vs_prem_wc<-cbind(final_mssa_predictor,final_components_preditor_array[shift,h,c(which(rownames(x_mat)<2020),which(rownames(x_mat)>2021))])
rownames(mssa_final_vs_prem_wc)<-rownames(x_mat_wc)
colnames(mssa_final_vs_prem_wc)<-c("Predictor based on final M-SSA","Predictor based on 2007-M-SSA")
par(mfrow=c(1,1))
colo<-c("blue","red")
mplot<-scale(mssa_final_vs_prem_wc)
colnames(mplot)<-colnames(mssa_final_vs_prem_wc)
main_title<-paste("BIP component predictors: final and 2007-MSSA (h=",h,", shift=",shift,")",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (jj in 1:ncol(mplot))
{
lines(mplot[,jj],col=colo[jj],lwd=1,lty=1)
mtext(colnames(mplot)[jj],col=colo[jj],line=-jj)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
#---------------------------------------------
# Compute impulse responses of old and of up-dated VAR
if (recompute_results)
{
# VAR based on full data set without pandemic
data_fit<-x_mat_wc
set.seed(12)
V_obj_full<-VARMA(data_fit,p=p,q=q)
threshold<-1.5
V_obj_full<-refVARMA(V_obj_full, thres = threshold)
save(V_obj_full,file=paste(path.result,"/VAR_full",sep=""))
# VAR based on data pre 2008
data_fit<-x_mat_wc[which(rownames(x_mat_wc)<date_to_fit),]
set.seed(12)
V_obj_2008<-VARMA(data_fit,p=p,q=q)
threshold<-1.5
V_obj_2008<-refVARMA(V_obj_2008, thres = threshold)
save(V_obj_2008,file=paste(path.result,"/VAR_2008",sep=""))
} else
{
load(file=paste(path.result,"/VAR_full",sep=""))
load(file=paste(path.result,"/VAR_2008",sep=""))
}
# Diagnostics are OK
if (F)
{
MTSdiag(V_obj_full)
MTSdiag(V_obj_2008)
}
# Compute MA-inversion
compute_xi_func<-function(V_obj,L)
{
Sigma<-V_obj$Sigma
V_obj$Phi
V_obj$Theta
n<-dim(Sigma)[1]
# MA inversion
xi_psi<-PSIwgt(Phi = V_obj$Phi, Theta = V_obj$Theta, lag = L, plot = F, output = F)
xi_p<-xi_psi$psi.weight
# Transform Xi_p into Xi: first L entries, from left to right, are weights of first WN, next L entries are weights of second WN
xi<-matrix(nrow=n,ncol=n*L)
for (i in 1:n)
{
for (j in 1:L)
xi[,(i-1)*L+j]<-xi_p[,i+(j-1)*n]
}
return(list(xi=xi))
}
xi_full<-compute_xi_func(V_obj_full,L)$xi
xi_2008<-compute_xi_func(V_obj_2008,L)$xi
colo<-rainbow(ncol(x_mat))
# Select BIP component
i<-1
par(mfrow=c(1,2))
# 2008
xi<-xi_2008
mplot<-xi[i,1:min(10,L)]
for (j in 2:n)
{
mplot<-cbind(mplot,xi[i,(j-1)*L+1:min(10,L)])
}
ts.plot(mplot,col=colo_i,main=paste("2008: MA inversion ",colnames(data_fit)[i],sep=""),xlab="lag")
for (k in 1:length(select_vec_i))
mtext(select_vec_i[k],line=-k,col=colo_i[k])
# full data set
xi<-xi_full
mplot<-xi[i,1:min(10,L)]
for (j in 2:n)
{
mplot<-cbind(mplot,xi[i,(j-1)*L+1:min(10,L)])
}
ts.plot(mplot,col=colo_i,main=paste("Full data: MA inversion ",colnames(data_fit)[i],sep=""),xlab="lag")
for (k in 1:length(select_vec_i))
mtext(select_vec_i[k],line=-k,col=colo_i[k])
bk_all<-matrix(final_mssa_indicator_obj$bk_x_array[select,select,,"h=4"],nrow=L)
bk_2008<-matrix(mssa_indicator_obj$bk_x_array[select,select,,"h=4"],nrow=L)
colnames(bk_2008)<-colnames(bk_all)<-select_vec_multi
par(mfrow=c(1,2))
mplot<-bk_2008
colo<-rainbow(ncol(mplot))
ts.plot(mplot,col=colo,main=paste("M-SSA 2008: h=",h,sep=""))
for (i in 1:ncol(mplot))
mtext(colnames(mplot)[i],col=colo[i],line=-i)
mplot<-bk_all
colo<-rainbow(ncol(mplot))
ts.plot(mplot,col=colo,main=paste("M-SSA full data: h=",h,sep=""))
for (i in 1:ncol(mplot))
mtext(colnames(mplot)[i],col=colo[i],line=-i)
